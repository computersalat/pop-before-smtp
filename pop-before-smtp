#!/usr/bin/perl -wT
use strict;

# Check the website <URL:http://popbsmtp.sf.net/> for the latest version,
# and the mailing list for discussing this program and asking for help at
# <URL:http://lists.sourceforge.net/lists/listinfo/popbsmtp-users>

# pop-before-smtp 1.30pre1
# Copyright (C) 1999, 2000, 2001 Bennett Todd, and (C) 2002 Wayne Davison.
# Freely Redistributable.

=head1 NAME

  pop-before-smtp - watch log for POP/IMAP auth, update map allowing SMTP

=head1 SYNOPSIS

  nohup pop-before-smtp [--config=FILE] [--[no]write] [--[no]debug] \
      [--[no]flock] [--watchlog=FILE] [--dbfile=FILE] [--logto=FILE] \
      [--grace=SECONDS] &

=head1 DESCRIPTION

pop-before-smtp watches /var/log/maillog for lines written by UW popd/imapd
describing successful login attempts, and installs entries for them in an
on-disk hash (DB) that is watched by postfix. It expires the entries after a
half-hour. The hash is named /etc/postfix/pop-before-smtp.db. The name, as
specified in the dbfile option, does not include the .db on the end, that's
tacked on to satisfy a wired-in assumption in postfix.

Internally, it keeps two data structures for all currently-allowed hosts; a
queue, and a hash. The queue contains [ipaddr, time] records, while the hash
contains ipaddr => time. Every time the daemon wakes up to deal with something
else from the File::Tail handle, it peeks a the front of the queue, and while
the timestamp of the record there has expired (is > 30 minutes old) it
tosses it, and if the timestamp in the hash is also expired and equals the
timestamp in the queue it deletes the hash entry and the on-disk db file
entry.

It contains support for protecting writes to the db file by flock.
As far as I know, the consequences of a collision (corrupt read in
an smtpd) are relatively mild, and the likelihood of one is remote,
but the performance impact of the locking seems to be negligible, so
it's enabled by default. To disable the flocking, invoke with
--noflock. Please let me know if you feel the default should be
changed, and if so why.

If invoked with --debug, it will emit a fair amount of nattering on
stdout, which may be helpful in diagnosing problems, then again it
may not. If invoked with --nowrite, it won't actually attempt to
write the db hash file; if your maillog is world-readable this might
allow you to try it out (with --debug) running as a non-privileged
user.

Edit the supplied pop-before-smtp-conf.pl file to change the wired-in logfile
format, tail parameters, etc.

When starting up, it builds an internal table of all netblocks natively
permitted by Postfix (it looks at the output of "postconf mynetworks"); before
adding each entry it checks to see if it would be permitted by that rule.

=head1 INSTALLATION

This daemon directly requires three modules from CPAN, which are not
included in the base Perl release as of this writing, and one of
those depends on another, so make sure you've downloaded and
installed suitably recent versions of

    File::Tail
    Time::HiRes (required by File::Tail)
    Net::Netmask
    Date::Parse (from TimeDate)

In addition, it depends on the DB_File module; if you don't have it
included in your perl build already (presumably because Berkeley DB
wasn't available when your Perl was configured and built) then you
can provide it by downloading the CPAN DB_File module, available
from http://www.cpan.org/authors/id/PMQS/DB_File-1.73.tar.gz.
Alternatively, if your Postfix supports some other on-disk-hash
table type (check supported map types with "postconf -m") then you
can just change from "use DB_File" to the appropriate module for
that hash type (listed in the AnyDBM_File pod documentation) and use
that instead, remembering also to change the map type from "hash" in
the below postfix main.cf config change. And if you change the map
type, you'll also need to adjust the "tie" statement that uses it in
this script, changing at least the second arg from DB_File to the
name of the module you're using, and probably dropping the $DB_HASH
argument out.

This daemon likes a couple of helpers. Here's a nice init script:

    #!/bin/sh
    progname=`basename $0`
    pgm=/usr/sbin/$progname
    log=/var/log/$progname
    pid=/var/run/$progname.pid
    die(){ echo "$progname: $*">&2; exit 1; }
    case "$1" in
    start) $pgm --logto=$log >/dev/null 2>&1 & echo $! >$pid;;
    stop) p=`cat $pid`; test -n "$p" || exit 0
        kill $p || exit 0; sleep 1
        kill -9 $p 2>/dev/null || exit 0; sleep 1
        kill -0 $p && die "$pid won't die"
        ;;
    esac

The integration in /etc/postfix/main.cf might look like this:

  smtpd_recipient_restrictions = permit_mynetworks,reject_non_fqdn_recipient,
        check_client_access hash:/etc/postfix/pop-before-smtp,
        check_relay_domains

=head1 TROUBLESHOOTING

Andy Dills <andy@xecu.net> reports that on his Solaris system,
File::Tail was hanging in the middle of reading a 15MB logfile. When
he removed "tail => -1" from the options (so the tail would start at
the end of the file, rather than at the beginning) that fixed it.

=head1 DOWNLOAD

See the website http://popbsmtp.sf.net/ for the latest version, and
the mailing list for support.

=head1 AUTHORS

Pop-before-smtp was created by Bennett Todd, <bet@rahul.net>.
It is currently being maintained by Wayne Davison <wayned@users.sf.net>.

=cut

use File::Tail;
use DB_File;
use Net::Netmask;
use Date::Parse;
use Date::Format;
use Getopt::Long;
use Fcntl ':flock';

use vars qw(
    $pat $write $flock $debug $reprocess $grace %file_tail
    @mynets %db $dbfile $dbvalue
    $mynet_func $tie_func $sync_func $flock_func $log_func
);

# Default values, possibly overridden in the config file.

$pat = '^(... .. ..:..:..) \S+ (?:ipop3s?d|imaps?d)\[\d+\]: ' .
    '(?:Login|Authenticated|Auth) user=\S+ ' .
    'host=(?:\S+ )?\[(\d+\.\d+\.\d+\.\d+)\](?: nmsgs=\d+/\d+)?$';
$write = 1; # open and change the DB
$flock = 1; # we do the exclusive file locking when updating
$debug = 0; # no debug messages
$reprocess = 0; # no debug reprocessing of watchlog
$dbfile = '/etc/postfix/pop-before-smtp'; # DB hash to write
$dbvalue = 'ok';
$grace = 30*60; # 30-minute grace period

$mynet_func = \&mynet_postfix;
$tie_func = \&tie_DB;
$sync_func = \&sync_DB;
$flock_func = \&flock_DB;

# See the pop-before-smtp-conf.pl file for what these values mean.
%file_tail = (
    name => '/var/log/maillog',
    maxinterval => 10,
    interval => 5,
    adjustafter => 3,
    tail => -1,
);

# Build complete sanitary environment.
%ENV = (
    PATH => '/usr/sbin:/usr/bin:/sbin:/bin:/usr/local/sbin:/usr/local/bin',
    HOME => '/tmp',
    SHELL => '/bin/sh',
    LOGNAME => getpwuid($<), # real me
);

my $config_file = '/etc/pop-before-smtp-conf.pl';

# Kludge the parsing of the --config=FILE option so we can parse the
# rest of our options after reading the config file.
if (@ARGV && $ARGV[0] =~ /^--config=(.*)/) {
    require $1;
    shift;
}
elsif (-f $config_file) {
    require $config_file;
}

GetOptions(
    'config=s' => sub {die "--config=$_[1] must be the first option.\n"},
    "write!" => \$write,
    "debug!" => sub { $debug = 1; $log_func = \&log_to_stdout },
    "flock!" => \$flock,
    "watchlog|logfile=s" => \$file_tail{'name'},
    'logto=s' => sub { set_output_log($_[1]) },
    "dbfile=s" => \$dbfile,
    "grace=i" => \$grace,
    "reprocess!" => \$reprocess,
) or die "Usage: $0 [--config=FILE] [--[no]write] [--[no]debug]\n    " .
    "[--[no]flock] [--watchlog=FILE] [--dbfile=FILE] [--logto=FILE]\n    " .
    "[--grace=SECONDS]\n";

$sync_func = sub { } if !$write;
$flock_func = sub { } if !$flock || !$write;
$log_func = sub { } unless $log_func;

my $fi = File::Tail->new(%file_tail);

$SIG{'INT'} = \&sig_handler;
$SIG{'TERM'} = \&sig_handler;
$SIG{__DIE__} = \&mydie;

$| = 1;

my $now = time;
$log_func->('info', 'starting up');

@mynets = cleanup_nets($mynet_func->());
Net::Netmask->new($_)->storeNetblock() for @mynets;

my (%t, @q);

if ($write) {
    $tie_func->();
    $flock_func->(1);
    foreach (keys %db) {
	delete $db{$_};
	$log_func->('debug', "removed old ip=$_ from DB") if $debug;
    }
    $flock_func->(0);
}

my $db_changed = 0;
my $last_expire_check = 0;

my($timestamp, $ipaddr);

while (1) {
    $_ = $fi->read;
    if ($reprocess) {
	# To assist with debugging, pretend the current time is when this
	# line's event happened.
	/^(... .. ..:..:..)/ and $now = str2time($1);
    }
    else {
	$now = time;
    }
    if (defined(&custom_match)) {
	($timestamp, $ipaddr) = &custom_match;
	next unless defined($ipaddr);
    }
    else {
	next unless ($timestamp, $ipaddr) = /$pat/o;
    }
    my $ts = str2time($timestamp) or next;
    $ts += $grace;
    next if $ts < $now;
    if (findNetblock($ipaddr)) {
	$log_func->('debug', "ignoring local-net ip=$ipaddr") if $debug;
	next;
    }
    $log_func->('debug', "found ip=$ipaddr") if $debug;
    push @q, [$ipaddr, $ts];
    my $already_enabled = exists($t{$ipaddr});
    $t{$ipaddr} = $ts;
    next if $already_enabled;
    $flock_func->(1);
    $db{$ipaddr} = $dbvalue;
    $log_func->('info', "added $ipaddr to DB");
    $db_changed = 1;
}
continue {
    if ($db_changed || $now > $last_expire_check + $grace) {
	while (@q && $q[0][1] <= $now) {
	    my($ipaddr,$ts) = @{shift @q};
	    if ($ts == $t{$ipaddr}) {
		if (!$db_changed) {
		    $flock_func->(1);
		    $db_changed = 1;
		}
		delete $t{$ipaddr};
		delete $db{$ipaddr};
		$log_func->('info', "removed $ipaddr from DB");
	    }
	}
	if ($db_changed) {
	    $sync_func->();
	    $flock_func->(0);
	    $db_changed = 0;
	}
	$last_expire_check = $now;
    }
}

exit;


sub cleanup_nets
{
    my @nets;
    foreach (@_) {
	# Detaint.  Also remove leading/trailing spaces.
	($_) = /^\s*(.*?)\s*$/s;
	foreach (split /[,\s]+/) {
	    if (m#^/#) {
		# Slurp the whole file into $_.
		undef $/;
		open(IN, $_) or die "Unable to open $_: $!";
		$_ = <IN>;
		close IN;
		$/ = "\n";
		# Remove any comments from the file's data.
		s/#.*//mg;
		push @nets, cleanup_nets($_);
	    }
	    else {
		push @nets, $_;
	    }
	}
    }
    @nets;
}

sub mynet_postfix
{
    $_ = `postconf mynetworks`;
    s/^mynetworks\s*=\s*//;
    $_;
}

my $dbh;

# We set the global %db to the opened database hash.  We also set $dbh for
# our sync_DB function, and DB_FH for our flock_DB function.
sub tie_DB
{
    $dbh = tie %db, 'DB_File', "$dbfile.db", O_CREAT|O_RDWR, 0666, $DB_HASH
	or die "$0: cannot dbopen $dbfile: $!\n";
    if ($flock) {
	my $fd = $dbh->fd;
	open(DB_FH,"+<&=$fd") or die "$0: cannot open $dbfile filehandle: $!\n";
    }
}

sub sync_DB
{
    $dbh->sync and die "$0: sync $dbfile: $!\n";
}

sub flock_DB
{
    if ($_[0]) {
	flock(DB_FH, LOCK_EX) or die "$0: flock LOCK_EX failed: $!\n";
    }
    else {
	flock(DB_FH, LOCK_UN) or die "$0: flock LOCK_UN failed: $!\n";
    }
}

sub log_to_stdout
{
    my $level = shift;
    print time2str('%b %e %T ', $now), @_, "\n";
}

sub set_output_log
{
    my($file) = @_;
    open(LOG, ">>$file") or die "Unable to append to $file: $!";
    $log_func = \&log_to_stdout;
    select(LOG);
}

sub sig_handler
{
    my($sig) = @_;
    $log_func->('crit', "caught SIG$sig -- exiting");
    exit 1;
}

sub mydie
{ 
    my($msg) = @_;
    $log_func->('crit', "fatal error: $msg") if defined $log_func;
}
